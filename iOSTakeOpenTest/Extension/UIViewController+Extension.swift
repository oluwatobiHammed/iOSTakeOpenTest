//
//  UIViewController+Extension.swift
//  iOSTakeOpenTest
//
//  Created by Oladipupo Oluwatobi on 10/06/2020.
//  Copyright Â© 2020 Oladipupo Oluwatobi. All rights reserved.
//

import Foundation
import UIKit
import RxSwift
import ContactsUI

public protocol ScrollOnlyOnKeyboardResponderDelegate {
    func getScrollView()-> UIScrollView?
    func shouldDisableScrollingOnKeyboardDismiss()-> Bool
}

var KEYBOARD_IS_SHOWN = false
var KEYBOARD_TAP_GESTURE: UITapGestureRecognizer?
var OLD_KEYBOARD_TAP_GESTURE: UITapGestureRecognizer?

@objc public protocol ChildControllerRemovedDelegate {
    @objc optional func willRemoveChildController(controller: UIViewController)
    @objc optional func didRemoveChildController(controller: UIViewController)
}

public protocol OnScreenKeyboardOffsetProvider {
    func offsetScreenOnKeyboardBy()-> CGFloat?
}
@objc protocol ViewControllerKeyboardOpeningDelegate {
    @objc optional func keyboardDidOpen()
    @objc optional func keyboardDidClose()
    
    @objc optional func keyboardWillOpen()
    @objc optional func keyboardWillClose()
}

extension UIViewController: UITextFieldDelegate {
    
    
    public func getNavigationViewController()-> UINavigationController? {
        if let navController = self.parent as? UINavigationController {
            return navController
        }
        return nil
    }
    
    public func displayViewController(fromRequest: ViewControllerPresentRequest) {
        
        if var disappearSubject = fromRequest.viewController as? ViewControllerPresentedDidDisappear {
            disappearSubject.didRemoveViewControllerSubject = fromRequest.didRemoveSubject
        }
        
        if var requestSetter = fromRequest.viewController as? ViewControllerPresentRequestDataReceiver {
            requestSetter.presentRequestData = fromRequest.requestData
        
        }
        switch fromRequest.mode {
        case .modal:
            fromRequest.viewController.modalPresentationStyle = .overCurrentContext
            self.present(fromRequest.viewController, animated: true, completion: nil)
        case .presentForce:
            self.present(fromRequest.viewController, animated: true, completion: nil)
        case .present:
            if let navController = self.navigationController {
                navController.pushViewController(fromRequest.viewController, animated: true)
            }
            else{
                self.present(fromRequest.viewController, animated: true, completion: nil)
            }
        case .root:
            let _ = UINavigationProvider.makeAsRoot(using: fromRequest.viewController)
        case .addToParent:
            self.addToParent(fromRequest.viewController)
        }
        fromRequest.didPresentSubject.onNext(true)
    }
    
    public func addToParent(_ child: UIViewController, slideFrom: SlideDirection? = nil, duration: TimeInterval = 0.5, completion: EmptyCallback? = nil) {
        let childView = child.view
        self.dismissKeyboard()
        if let slideFrom = slideFrom {
            switch slideFrom {
            case .top:
                childView?.frame.origin.y = 0.0 - self.view.frame.height
            case .bottom:
                childView?.frame.origin.y = self.view.frame.height
            case .left:
                childView?.frame.origin.x = 0.0 - self.view.frame.width
            case .right:
                childView?.frame.origin.x = self.view.frame.width
            }
        }
        else {
            childView?.alpha = 0
        }
        
        addChild(child)
        self.view.addSubview(child.view)
        
        
        UIView.animate(withDuration: duration, animations: {
            if let slideFrom = slideFrom {
                switch slideFrom {
                case .top:
                    childView?.frame.origin.y = 0
                case .bottom:
                    childView?.frame.origin.y = 0
                case .left:
                    childView?.frame.origin.x = 0
                case .right:
                    childView?.frame.origin.x = 0
                }
            }
            else {
                childView?.alpha = 1
            }
        }){ (completed: Bool) in
            child.didMove(toParent: self)
            if let completion = completion {
                completion()
            }
        }
    }
    
    public func removeFromParentViewController(slideTowards: SlideDirection? = .bottom, duration: TimeInterval = 0.5, completion: EmptyCallback? = nil) {
        guard parent != nil else {
            return
        }
        
        let parentView = parent!.view!
        
        willMove(toParent: nil)
        
        let parentController = self.parent as? ChildControllerRemovedDelegate
        if let parent = parentController {
            parent.willRemoveChildController?(controller: self)
        }
        UIView.animate(withDuration: 1, animations: {
            
            if let slideTowards = slideTowards {
                switch slideTowards {
                case .top:
                    self.view.frame.origin.y = 0.0 - parentView.frame.height
                case .bottom:
                    self.view.frame.origin.y = parentView.frame.height
                case .left:
                    self.view.frame.origin.x = 0.0 - parentView.frame.width
                case .right:
                    self.view.frame.origin.x = parentView.frame.width
                }
            }
            else {
                self.view.alpha = 0
            }
            
        }){ (completed: Bool) in
            
            self.removeFromParent()
            self.view.removeFromSuperview()
            if let parent = parentController {
                parent.didRemoveChildController?(controller: self)
            }
        }
    }
    
 
    
    func onRemovingFromParent() {
        if var invoker = self as? ViewControllerPresentedDidDisappear {
            invoker.didRemoveViewControllerSubject?.onNext(invoker.viewControllerWillDisappearData)
            invoker.didRemoveViewControllerSubject?.onCompleted()
            invoker.didRemoveViewControllerSubject = nil
        }
    }
    
    func addKeyboardOpeningEvent() {
           NotificationCenter.default.addObserver(self, selector: #selector(self.keyboardWasShown), name: NSNotification.Name(rawValue: UIResponder.keyboardDidShowNotification.rawValue), object: nil)
           
           NotificationCenter.default.addObserver(self, selector: #selector(self.keyboardWillBeHidden), name: NSNotification.Name(rawValue: UIResponder.keyboardWillHideNotification.rawValue), object: nil)
       }
    
    func removeKeyboardOpeningEvent() {
          NotificationCenter.default.removeObserver(self, name: NSNotification.Name(rawValue: UIResponder.keyboardDidShowNotification.rawValue), object: nil)
          
          NotificationCenter.default.removeObserver(self, name: NSNotification.Name(rawValue: UIResponder.keyboardWillHideNotification.rawValue), object: nil)
      }
    
    @objc func keyboardWasShown(notification: Notification) {
         
         if let presented = self.presentedViewController {
             if type(of: presented) == CNContactPickerViewController.self {
                 return
             }
         }
         
         KEYBOARD_IS_SHOWN = true
         
         if KEYBOARD_TAP_GESTURE == nil {
             KEYBOARD_TAP_GESTURE = UITapGestureRecognizer(target: self, action: #selector(dismissKeyboard(recognizer:reset:)))
             self.view.addGestureRecognizer(KEYBOARD_TAP_GESTURE!)
         }
         
         if let notifyer = self as? ViewControllerKeyboardOpeningDelegate {
             notifyer.keyboardWillOpen?()
         }
         
         if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue,
             let window = self.view.window?.frame {
             // We're not just minusing the kb height from the view height because
             // the view could already have been resized for the keyboard before
             //OnScreenKeyboardOffsetProvider
             var height = keyboardSize.height
             if let provider = self as? OnScreenKeyboardOffsetProvider, let providerHeight = provider.offsetScreenOnKeyboardBy() {
                 height = providerHeight
             }
             self.view.frame = CGRect(x: self.view.frame.origin.x,
                                      y: self.view.frame.origin.y,
                                      width: self.view.frame.width,
                                      height: window.origin.y + window.height - height)
         } else {
             debugPrint("We're showing the keyboard and either the keyboard size or window is nil: panic widely.")
         }
         
         DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
             if let scrolling = self as? ScrollOnlyOnKeyboardResponderDelegate {
                 if let scroller = scrolling.getScrollView() {
                     scroller.isScrollEnabled = true
                     if let responder = UIResponder.currentFirstResponder {
                         if let view = responder as? UIView {
                             let scrollPosition = view.convert(view.center, to: scroller)
                             let rect = CGRect(x: scrollPosition.x, y: scrollPosition.y, width: view.frame.width, height: view.frame.height)
                             scroller.scrollRectToVisible(rect, animated: true)
                         }
                     }
                 }
             }
         }
         
         if let notifyer = self as? ViewControllerKeyboardOpeningDelegate {
             notifyer.keyboardDidOpen?()
         }
     }
    
    @objc func keyboardWillBeHidden(notification: Notification) {
        
        if let presented = self.presentedViewController {
            if type(of: presented) == CNContactPickerViewController.self {
                return
            }
        }
        KEYBOARD_IS_SHOWN = false
        if let rec = KEYBOARD_TAP_GESTURE {
            self.view.removeGestureRecognizer(rec)
            KEYBOARD_TAP_GESTURE = nil
        }
        if let notifyer = self as? ViewControllerKeyboardOpeningDelegate {
            notifyer.keyboardWillClose?()
        }
        if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
            let viewHeight = self.view.frame.height
            var height = keyboardSize.height
            if let provider = self as? OnScreenKeyboardOffsetProvider, let providerHeight = provider.offsetScreenOnKeyboardBy() {
                height = providerHeight
            }
            
            self.view.frame = CGRect(x: self.view.frame.origin.x,
                                     y: self.view.frame.origin.y,
                                     width: self.view.frame.width,
                                     height: viewHeight + height)
        } else {
            debugPrint("We're about to hide the keyboard and the keyboard size is nil. Now is the rapture.")
        }
        if let scrolling = self as? ScrollOnlyOnKeyboardResponderDelegate {
            if let scroller = scrolling.getScrollView() {
                
                if scrolling.shouldDisableScrollingOnKeyboardDismiss() {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        scroller.scrollRectToVisible(CGRect(x: 0, y:0, width:10, height: 10), animated: true)
                        scroller.isScrollEnabled = false
                    }
                }
                
            }
        }
        if let notifyer = self as? ViewControllerKeyboardOpeningDelegate {
            notifyer.keyboardDidClose?()
        }
    }
    
    @objc func dismissKeyboard(recognizer: UITapGestureRecognizer? = nil, reset: Bool = false){
          if KEYBOARD_IS_SHOWN {
              view.endEditing(true)
              if reset {
                  KEYBOARD_IS_SHOWN = false
              }
          }
      }
}

